The auto coding library uses e2e tests as unit testing. The idea is
- run a mocked UI project in an actual browser
- mock backend API response so that tests don't depend on backend
- mock custom components and test if auto coding library load custom components correctly and pass correct properties to custom components
- provide helper functions for a test to access UI components, such as read table cell by field name, select a date, etc.

## Run test

Test cases are located in the AutoCoding repository's `test` folder.
In the auto coding repository,

- use `npm run build:testapp` to generate the test UI project.
- use `npm run test` to run test cases, use `npm run test -- {testfilename}` to run specific test file.
    - Test report is located in `./html-report` folder
    - Code coverage needs to be generated by executing `npm run gen:coverage` command. Code coverage report located in `./html-report/coverage` folder.


## Test Case Example

```javascript

  test(`should ask confirm when delete a row in table`, async () => {
    const page = await newTestPage(BannedVisitorsTestPage);
    await page
      .actions()
      // this is a metho of BannedVisitorsTestPage, which mocks response of /bannedvisitors endpoint
      .mockBannedVisitors()
      .gotoBannedVisitorPage()
      .deleteFirstRowAndConfirm()
      // after click `OK` button of dialog, we wait for success message popup and check the sucess message
      .waitForSuccessMessage()
      .expect.toBe("Banned Visitor deleted successfully.")
      .perform();
  });


//
// in BannedVisitorsTestPage
//


class BannedVisitorsTestPage extends AutoCodingTestPage {
  gotoBannedVisitorPage() {
    return this.goto("/livechat/settings/banlist/bannedvisitor/");
  }

  deleteFirstRowAndConfirm() {
    return this.actions()
      // typical operation: {component name}.{verb}({selector})
      .iconButton.click({
        selector: "table.operation",
        row: { index: 0 },
        operation: { label: "Delete" },
      })
      .confirmDialog.accept("confirmDialog");
  }

  mockBannedVisitors() {
    // this.mock.get here mocks response for `GET https:///livechat/bannedVisitors` 
    // Document of this api is here: 
    //     https://dash11.comm100.io/doc/LiveChat/bannedVisitor#GETlivechat/bannedVisitors
    // You can create a request in Postman and copy the response body as fakeBannedVisitor
    this.mock.get("/livechat/bannedVisitors", [fakeBannedVisitor]);
  }
}

const fakeBannedVisitor = {
  id: "570ee3f5-2d8a-4b5f-928d-7a2e3468a1bc",
  visitorId: "f2209b37-00fe-4422-876c-9823e3d759aa",
  comment: "test comment",
  lastUpdatedTime: "2021-07-06T09:43:32.04Z",
  agentId: "3b6757c8-7594-4a19-bdf5-d327a13d5095",
  createdTime: "2021-07-06T09:43:32.04Z",
};

```


## Layers of test

Following are layers of a test case, from top to bottom:
(Test environment, browser, and driver's code are located in [E2ETest](/Topics/Front-End-Repositories) repo)

- test case
  Do a series of steps and check the result
- test page
  helper functions, each function is a step (reusable) of a test. For example, gotoCampaignPage, submit a form, etc.
- test environment
  jest environment, launch/close browser for each test case
- browser, page, components
  component level actions, such as change a select, change a date, read from a table cell, etc.
- driver, driver page, driver element
  low-level interface to talk to the browser

